# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-01-31 15:04+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../library/zipapp.rst:2
msgid ":mod:`zipapp` --- Manage executable python zip archives"
msgstr ""

#: ../../library/zipapp.rst:13
msgid "**Source code:** :source:`Lib/zipapp.py`"
msgstr ""

#: ../../library/zipapp.rst:17
msgid "This module provides tools to manage the creation of zip files containing Python code, which can be  :ref:`executed directly by the Python interpreter <using-on-interface-options>`.  The module provides both a :ref:`zipapp-command-line-interface` and a :ref:`zipapp-python-api`."
msgstr ""

#: ../../library/zipapp.rst:24
msgid "Basic Example"
msgstr ""

#: ../../library/zipapp.rst:26
msgid "The following example shows how the :ref:`command-line-interface` can be used to create an executable archive from a directory containing Python code.  When run, the archive will execute the ``main`` function from the module ``myapp`` in the archive."
msgstr ""

#: ../../library/zipapp.rst:41
msgid "Command-Line Interface"
msgstr ""

#: ../../library/zipapp.rst:43
msgid "When called as a program from the command line, the following form is used:"
msgstr ""

#: ../../library/zipapp.rst:49
msgid "If *source* is a directory, this will create an archive from the contents of *source*.  If *source* is a file, it should be an archive, and it will be copied to the target archive (or the contents of its shebang line will be displayed if the --info option is specified)."
msgstr ""

#: ../../library/zipapp.rst:54
msgid "The following options are understood:"
msgstr ""

#: ../../library/zipapp.rst:60
msgid "Write the output to a file named *output*.  If this option is not specified, the output filename will be the same as the input *source*, with the extension ``.pyz`` added.  If an explicit filename is given, it is used as is (so a ``.pyz`` extension should be included if required)."
msgstr ""

#: ../../library/zipapp.rst:65
msgid "An output filename must be specified if the *source* is an archive (and in that case, *output* must not be the same as *source*)."
msgstr ""

#: ../../library/zipapp.rst:70
msgid "Add a ``#!`` line to the archive specifying *interpreter* as the command to run.  Also, on POSIX, make the archive executable.  The default is to write no ``#!`` line, and not make the file executable."
msgstr ""

#: ../../library/zipapp.rst:76
msgid "Write a ``__main__.py`` file to the archive that executes *mainfn*.  The *mainfn* argument should have the form \"pkg.mod:fn\", where \"pkg.mod\" is a package/module in the archive, and \"fn\" is a callable in the given module. The ``__main__.py`` file will execute that callable."
msgstr ""

#: ../../library/zipapp.rst:81
msgid ":option:`--main` cannot be specified when copying an archive."
msgstr ""

#: ../../library/zipapp.rst:85
msgid "Display the interpreter embedded in the archive, for diagnostic purposes.  In this case, any other options are ignored and SOURCE must be an archive, not a directory."
msgstr ""

#: ../../library/zipapp.rst:91
msgid "Print a short usage message and exit."
msgstr ""

#: ../../library/zipapp.rst:97
msgid "Python API"
msgstr ""

#: ../../library/zipapp.rst:99
msgid "The module defines two convenience functions:"
msgstr ""

#: ../../library/zipapp.rst:104
msgid "Create an application archive from *source*.  The source can be any of the following:"
msgstr ""

#: ../../library/zipapp.rst:107
msgid "The name of a directory, or a :class:`pathlib.Path` object referring to a directory, in which case a new application archive will be created from the content of that directory."
msgstr ""

#: ../../library/zipapp.rst:110
msgid "The name of an existing application archive file, or a :class:`pathlib.Path` object referring to such a file, in which case the file is copied to the target (modifying it to reflect the value given for the *interpreter* argument).  The file name should include the ``.pyz`` extension, if required."
msgstr ""

#: ../../library/zipapp.rst:114
msgid "A file object open for reading in bytes mode.  The content of the file should be an application archive, and the file object is assumed to be positioned at the start of the archive."
msgstr ""

#: ../../library/zipapp.rst:118
msgid "The *target* argument determines where the resulting archive will be written:"
msgstr ""

#: ../../library/zipapp.rst:121
msgid "If it is the name of a file, or a :class:`pathlb.Path` object, the archive will be written to that file."
msgstr ""

#: ../../library/zipapp.rst:123
msgid "If it is an open file object, the archive will be written to that file object, which must be open for writing in bytes mode."
msgstr ""

#: ../../library/zipapp.rst:125
msgid "If the target is omitted (or None), the source must be a directory and the target will be a file with the same name as the source, with a ``.pyz`` extension added."
msgstr ""

#: ../../library/zipapp.rst:129
msgid "The *interpreter* argument specifies the name of the Python interpreter with which the archive will be executed.  It is written as a \"shebang\" line at the start of the archive.  On POSIX, this will be interpreted by the OS, and on Windows it will be handled by the Python launcher.  Omitting the *interpreter* results in no shebang line being written.  If an interpreter is specified, and the target is a filename, the executable bit of the target file will be set."
msgstr ""

#: ../../library/zipapp.rst:137
msgid "The *main* argument specifies the name of a callable which will be used as the main program for the archive.  It can only be specified if the source is a directory, and the source does not already contain a ``__main__.py`` file.  The *main* argument should take the form \"pkg.module:callable\" and the archive will be run by importing \"pkg.module\" and executing the given callable with no arguments.  It is an error to omit *main* if the source is a directory and does not contain a ``__main__.py`` file, as otherwise the resulting archive would not be executable."
msgstr ""

#: ../../library/zipapp.rst:147
msgid "If a file object is specified for *source* or *target*, it is the caller's responsibility to close it after calling create_archive."
msgstr ""

#: ../../library/zipapp.rst:150
msgid "When copying an existing archive, file objects supplied only need ``read`` and ``readline``, or ``write`` methods.  When creating an archive from a directory, if the target is a file object it will be passed to the ``zipfile.ZipFile`` class, and must supply the methods needed by that class."
msgstr ""

#: ../../library/zipapp.rst:158
msgid "Return the interpreter specified in the ``#!`` line at the start of the archive.  If there is no ``#!`` line, return :const:`None`. The *archive* argument can be a filename or a file-like object open for reading in bytes mode.  It is assumed to be at the start of the archive."
msgstr ""

#: ../../library/zipapp.rst:167
msgid "Examples"
msgstr ""

#: ../../library/zipapp.rst:169
msgid "Pack up a directory into an archive, and run it."
msgstr ""

#: ../../library/zipapp.rst:177
msgid "The same can be done using the :func:`create_archive` functon::"
msgstr ""

#: ../../library/zipapp.rst:182
msgid "To make the application directly executable on POSIX, specify an interpreter to use."
msgstr ""

#: ../../library/zipapp.rst:191
msgid "To replace the shebang line on an existing archive, create a modified archive using the :func:`create_archive` function::"
msgstr ""

#: ../../library/zipapp.rst:197
msgid "To update the file in place, do the replacement in memory using a :class:`BytesIO` object, and then overwrite the source afterwards.  Note that there is a risk when overwriting a file in place that an error will result in the loss of the original file.  This code does not protect against such errors, but production code should do so.  Also, this method will only work if the archive fits in memory::"
msgstr ""

#: ../../library/zipapp.rst:211
msgid "Note that if you specify an interpreter and then distribute your application archive, you need to ensure that the interpreter used is portable.  The Python launcher for Windows supports most common forms of POSIX ``#!`` line, but there are other issues to consider:"
msgstr ""

#: ../../library/zipapp.rst:216
msgid "If you use \"/usr/bin/env python\" (or other forms of the \"python\" command, such as \"/usr/bin/python\"), you need to consider that your users may have either Python 2 or Python 3 as their default, and write your code to work under both versions."
msgstr ""

#: ../../library/zipapp.rst:220
msgid "If you use an explicit version, for example \"/usr/bin/env python3\" your application will not work for users who do not have that version.  (This may be what you want if you have not made your code Python 2 compatible)."
msgstr ""

#: ../../library/zipapp.rst:223
msgid "There is no way to say \"python X.Y or later\", so be careful of using an exact version like \"/usr/bin/env python3.4\" as you will need to change your shebang line for users of Python 3.5, for example."
msgstr ""

#: ../../library/zipapp.rst:228
msgid "The Python Zip Application Archive Format"
msgstr ""

#: ../../library/zipapp.rst:230
msgid "Python has been able to execute zip files which contain a ``__main__.py`` file since version 2.6.  In order to be executed by Python, an application archive simply has to be a standard zip file containing a ``__main__.py`` file which will be run as the entry point for the application.  As usual for any Python script, the parent of the script (in this case the zip file) will be placed on :data:`sys.path` and thus further modules can be imported from the zip file."
msgstr ""

#: ../../library/zipapp.rst:237
msgid "The zip file format allows arbitrary data to be prepended to a zip file.  The zip application format uses this ability to prepend a standard POSIX \"shebang\" line to the file (``#!/path/to/interpreter``)."
msgstr ""

#: ../../library/zipapp.rst:241
msgid "Formally, the Python zip application format is therefore:"
msgstr ""

#: ../../library/zipapp.rst:243
msgid "An optional shebang line, containing the characters ``b'#!'`` followed by an interpreter name, and then a newline (``b'\\n'``) character.  The interpreter name can be anything acceptable to the OS \"shebang\" processing, or the Python launcher on Windows.  The interpreter should be encoded in UTF-8 on Windows, and in :func:`sys.getfilesystemencoding()` on POSIX."
msgstr ""

#: ../../library/zipapp.rst:248
msgid "Standard zipfile data, as generated by the :mod:`zipfile` module.  The zipfile content *must* include a file called ``__main__.py`` (which must be in the \"root\" of the zipfile - i.e., it cannot be in a subdirectory).  The zipfile data can be compressed or uncompressed."
msgstr ""

#: ../../library/zipapp.rst:253
msgid "If an application archive has a shebang line, it may have the executable bit set on POSIX systems, to allow it to be executed directly."
msgstr ""

#: ../../library/zipapp.rst:256
msgid "There is no requirement that the tools in this module are used to create application archives - the module is a convenience, but archives in the above format created by any means are acceptable to Python."
msgstr ""

