# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-01-31 15:04+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../library/struct.rst:2
msgid ":mod:`struct` --- Interpret bytes as packed binary data"
msgstr ""

#: ../../library/struct.rst:11
msgid "This module performs conversions between Python values and C structs represented as Python :class:`bytes` objects.  This can be used in handling binary data stored in files or from network connections, among other sources.  It uses :ref:`struct-format-strings` as compact descriptions of the layout of the C structs and the intended conversion to/from Python values."
msgstr ""

#: ../../library/struct.rst:19
msgid "By default, the result of packing a given C struct includes pad bytes in order to maintain proper alignment for the C types involved; similarly, alignment is taken into account when unpacking.  This behavior is chosen so that the bytes of a packed struct correspond exactly to the layout in memory of the corresponding C struct.  To handle platform-independent data formats or omit implicit pad bytes, use ``standard`` size and alignment instead of ``native`` size and alignment: see :ref:`struct-alignment` for details."
msgstr ""

#: ../../library/struct.rst:27
msgid "Several :mod:`struct` functions (and methods of :class:`Struct`) take a *buffer* argument.  This refers to objects that implement the :ref:`bufferobjects` and provide either a readable or read-writable buffer.  The most common types used for that purpose are :class:`bytes` and :class:`bytearray`, but many other types that can be viewed as an array of bytes implement the buffer protocol, so that they can be read/filled without additional copying from a :class:`bytes` object."
msgstr ""

#: ../../library/struct.rst:36
msgid "Functions and Exceptions"
msgstr ""

#: ../../library/struct.rst:38
msgid "The module defines the following exception and functions:"
msgstr ""

#: ../../library/struct.rst:43
msgid "Exception raised on various occasions; argument is a string describing what is wrong."
msgstr ""

#: ../../library/struct.rst:49
msgid "Return a bytes object containing the values *v1*, *v2*, ... packed according to the format string *fmt*.  The arguments must match the values required by the format exactly."
msgstr ""

#: ../../library/struct.rst:56
msgid "Pack the values *v1*, *v2*, ... according to the format string *fmt* and write the packed bytes into the writable buffer *buffer* starting at position *offset*.  Note that *offset* is a required argument."
msgstr ""

#: ../../library/struct.rst:63
msgid "Unpack from the buffer *buffer* (presumably packed by ``pack(fmt, ...)``) according to the format string *fmt*.  The result is a tuple even if it contains exactly one item.  The buffer must contain exactly the amount of data required by the format (``len(bytes)`` must equal ``calcsize(fmt)``)."
msgstr ""

#: ../../library/struct.rst:71
msgid "Unpack from *buffer* starting at position *offset*, according to the format string *fmt*.  The result is a tuple even if it contains exactly one item.  *buffer* must contain at least the amount of data required by the format (``len(buffer[offset:])`` must be at least ``calcsize(fmt)``)."
msgstr ""

#: ../../library/struct.rst:79
msgid "Iteratively unpack from the buffer *buffer* according to the format string *fmt*.  This function returns an iterator which will read equally-sized chunks from the buffer until all its contents have been consumed.  The buffer's size in bytes must be a multiple of the amount of data required by the format, as reflected by :func:`calcsize`."
msgstr ""

#: ../../library/struct.rst:85
msgid "Each iteration yields a tuple as specified by the format string."
msgstr ""

#: ../../library/struct.rst:92
msgid "Return the size of the struct (and hence of the bytes object produced by ``pack(fmt, ...)``) corresponding to the format string *fmt*."
msgstr ""

#: ../../library/struct.rst:98
msgid "Format Strings"
msgstr ""

#: ../../library/struct.rst:100
msgid "Format strings are the mechanism used to specify the expected layout when packing and unpacking data.  They are built up from :ref:`format-characters`, which specify the type of data being packed/unpacked.  In addition, there are special characters for controlling the :ref:`struct-alignment`."
msgstr ""

#: ../../library/struct.rst:109
msgid "Byte Order, Size, and Alignment"
msgstr ""

#: ../../library/struct.rst:111
msgid "By default, C types are represented in the machine's native format and byte order, and properly aligned by skipping pad bytes if necessary (according to the rules used by the C compiler)."
msgstr ""

#: ../../library/struct.rst:115
msgid "Alternatively, the first character of the format string can be used to indicate the byte order, size and alignment of the packed data, according to the following table:"
msgstr ""

#: ../../library/struct.rst:120
msgid "Character"
msgstr ""

#: ../../library/struct.rst:120
msgid "Byte order"
msgstr ""

#: ../../library/struct.rst:120
msgid "Size"
msgstr ""

#: ../../library/struct.rst:120
msgid "Alignment"
msgstr ""

#: ../../library/struct.rst:122
msgid "``@``"
msgstr ""

#: ../../library/struct.rst:122
#: ../../library/struct.rst:122
#: ../../library/struct.rst:122
#: ../../library/struct.rst:124
msgid "native"
msgstr ""

#: ../../library/struct.rst:124
msgid "``=``"
msgstr ""

#: ../../library/struct.rst:124
#: ../../library/struct.rst:126
#: ../../library/struct.rst:128
#: ../../library/struct.rst:130
msgid "standard"
msgstr ""

#: ../../library/struct.rst:124
#: ../../library/struct.rst:126
#: ../../library/struct.rst:128
#: ../../library/struct.rst:130
msgid "none"
msgstr ""

#: ../../library/struct.rst:126
msgid "``<``"
msgstr ""

#: ../../library/struct.rst:126
msgid "little-endian"
msgstr ""

#: ../../library/struct.rst:128
msgid "``>``"
msgstr ""

#: ../../library/struct.rst:128
msgid "big-endian"
msgstr ""

#: ../../library/struct.rst:130
msgid "``!``"
msgstr ""

#: ../../library/struct.rst:130
msgid "network (= big-endian)"
msgstr ""

#: ../../library/struct.rst:133
msgid "If the first character is not one of these, ``'@'`` is assumed."
msgstr ""

#: ../../library/struct.rst:135
msgid "Native byte order is big-endian or little-endian, depending on the host system. For example, Intel x86 and AMD64 (x86-64) are little-endian; Motorola 68000 and PowerPC G5 are big-endian; ARM and Intel Itanium feature switchable endianness (bi-endian). Use ``sys.byteorder`` to check the endianness of your system."
msgstr ""

#: ../../library/struct.rst:141
msgid "Native size and alignment are determined using the C compiler's ``sizeof`` expression.  This is always combined with native byte order."
msgstr ""

#: ../../library/struct.rst:144
msgid "Standard size depends only on the format character;  see the table in the :ref:`format-characters` section."
msgstr ""

#: ../../library/struct.rst:147
msgid "Note the difference between ``'@'`` and ``'='``: both use native byte order, but the size and alignment of the latter is standardized."
msgstr ""

#: ../../library/struct.rst:150
msgid "The form ``'!'`` is available for those poor souls who claim they can't remember whether network byte order is big-endian or little-endian."
msgstr ""

#: ../../library/struct.rst:153
msgid "There is no way to indicate non-native byte order (force byte-swapping); use the appropriate choice of ``'<'`` or ``'>'``."
msgstr ""

#: ../../library/struct.rst:156
#: ../../library/struct.rst:229
msgid "Notes:"
msgstr ""

#: ../../library/struct.rst:158
msgid "Padding is only automatically added between successive structure members. No padding is added at the beginning or the end of the encoded struct."
msgstr ""

#: ../../library/struct.rst:161
msgid "No padding is added when using non-native size and alignment, e.g. with '<', '>', '=', and '!'."
msgstr ""

#: ../../library/struct.rst:164
msgid "To align the end of a structure to the alignment requirement of a particular type, end the format with the code for that type with a repeat count of zero.  See :ref:`struct-examples`."
msgstr ""

#: ../../library/struct.rst:172
msgid "Format Characters"
msgstr ""

#: ../../library/struct.rst:174
msgid "Format characters have the following meaning; the conversion between C and Python values should be obvious given their types.  The 'Standard size' column refers to the size of the packed value in bytes when using standard size; that is, when the format string starts with one of ``'<'``, ``'>'``, ``'!'`` or ``'='``.  When using native size, the size of the packed value is platform-dependent."
msgstr ""

#: ../../library/struct.rst:182
msgid "Format"
msgstr ""

#: ../../library/struct.rst:182
msgid "C Type"
msgstr ""

#: ../../library/struct.rst:182
msgid "Python type"
msgstr ""

#: ../../library/struct.rst:182
msgid "Standard size"
msgstr ""

#: ../../library/struct.rst:182
msgid "Notes"
msgstr ""

#: ../../library/struct.rst:184
msgid "``x``"
msgstr ""

#: ../../library/struct.rst:184
msgid "pad byte"
msgstr ""

#: ../../library/struct.rst:184
msgid "no value"
msgstr ""

#: ../../library/struct.rst:186
msgid "``c``"
msgstr ""

#: ../../library/struct.rst:186
msgid ":c:type:`char`"
msgstr ""

#: ../../library/struct.rst:186
msgid "bytes of length 1"
msgstr ""

#: ../../library/struct.rst:186
#: ../../library/struct.rst:188
#: ../../library/struct.rst:190
#: ../../library/struct.rst:192
msgid "1"
msgstr ""

#: ../../library/struct.rst:188
msgid "``b``"
msgstr ""

#: ../../library/struct.rst:188
msgid ":c:type:`signed char`"
msgstr ""

#: ../../library/struct.rst:188
#: ../../library/struct.rst:190
#: ../../library/struct.rst:194
#: ../../library/struct.rst:196
#: ../../library/struct.rst:198
#: ../../library/struct.rst:200
#: ../../library/struct.rst:202
#: ../../library/struct.rst:204
#: ../../library/struct.rst:206
#: ../../library/struct.rst:208
#: ../../library/struct.rst:211
#: ../../library/struct.rst:213
#: ../../library/struct.rst:223
msgid "integer"
msgstr ""

#: ../../library/struct.rst:188
msgid "\\(1),\\(3)"
msgstr ""

#: ../../library/struct.rst:190
msgid "``B``"
msgstr ""

#: ../../library/struct.rst:190
msgid ":c:type:`unsigned char`"
msgstr ""

#: ../../library/struct.rst:190
#: ../../library/struct.rst:194
#: ../../library/struct.rst:196
#: ../../library/struct.rst:198
#: ../../library/struct.rst:200
#: ../../library/struct.rst:202
#: ../../library/struct.rst:204
msgid "\\(3)"
msgstr ""

#: ../../library/struct.rst:192
msgid "``?``"
msgstr ""

#: ../../library/struct.rst:192
msgid ":c:type:`_Bool`"
msgstr ""

#: ../../library/struct.rst:192
msgid "bool"
msgstr ""

#: ../../library/struct.rst:192
msgid "\\(1)"
msgstr ""

#: ../../library/struct.rst:194
msgid "``h``"
msgstr ""

#: ../../library/struct.rst:194
msgid ":c:type:`short`"
msgstr ""

#: ../../library/struct.rst:194
#: ../../library/struct.rst:196
msgid "2"
msgstr ""

#: ../../library/struct.rst:196
msgid "``H``"
msgstr ""

#: ../../library/struct.rst:196
msgid ":c:type:`unsigned short`"
msgstr ""

#: ../../library/struct.rst:198
msgid "``i``"
msgstr ""

#: ../../library/struct.rst:198
msgid ":c:type:`int`"
msgstr ""

#: ../../library/struct.rst:198
#: ../../library/struct.rst:200
#: ../../library/struct.rst:202
#: ../../library/struct.rst:204
#: ../../library/struct.rst:215
msgid "4"
msgstr ""

#: ../../library/struct.rst:200
msgid "``I``"
msgstr ""

#: ../../library/struct.rst:200
msgid ":c:type:`unsigned int`"
msgstr ""

#: ../../library/struct.rst:202
msgid "``l``"
msgstr ""

#: ../../library/struct.rst:202
msgid ":c:type:`long`"
msgstr ""

#: ../../library/struct.rst:204
msgid "``L``"
msgstr ""

#: ../../library/struct.rst:204
msgid ":c:type:`unsigned long`"
msgstr ""

#: ../../library/struct.rst:206
msgid "``q``"
msgstr ""

#: ../../library/struct.rst:206
msgid ":c:type:`long long`"
msgstr ""

#: ../../library/struct.rst:206
#: ../../library/struct.rst:208
#: ../../library/struct.rst:217
msgid "8"
msgstr ""

#: ../../library/struct.rst:206
#: ../../library/struct.rst:208
msgid "\\(2), \\(3)"
msgstr ""

#: ../../library/struct.rst:208
msgid "``Q``"
msgstr ""

#: ../../library/struct.rst:208
msgid ":c:type:`unsigned long long`"
msgstr ""

#: ../../library/struct.rst:211
msgid "``n``"
msgstr ""

#: ../../library/struct.rst:211
msgid ":c:type:`ssize_t`"
msgstr ""

#: ../../library/struct.rst:211
#: ../../library/struct.rst:213
msgid "\\(4)"
msgstr ""

#: ../../library/struct.rst:213
msgid "``N``"
msgstr ""

#: ../../library/struct.rst:213
msgid ":c:type:`size_t`"
msgstr ""

#: ../../library/struct.rst:215
msgid "``f``"
msgstr ""

#: ../../library/struct.rst:215
msgid ":c:type:`float`"
msgstr ""

#: ../../library/struct.rst:215
#: ../../library/struct.rst:217
msgid "float"
msgstr ""

#: ../../library/struct.rst:215
#: ../../library/struct.rst:217
msgid "\\(5)"
msgstr ""

#: ../../library/struct.rst:217
msgid "``d``"
msgstr ""

#: ../../library/struct.rst:217
msgid ":c:type:`double`"
msgstr ""

#: ../../library/struct.rst:219
msgid "``s``"
msgstr ""

#: ../../library/struct.rst:219
#: ../../library/struct.rst:221
msgid ":c:type:`char[]`"
msgstr ""

#: ../../library/struct.rst:219
#: ../../library/struct.rst:221
msgid "bytes"
msgstr ""

#: ../../library/struct.rst:221
msgid "``p``"
msgstr ""

#: ../../library/struct.rst:223
msgid "``P``"
msgstr ""

#: ../../library/struct.rst:223
msgid ":c:type:`void \\*`"
msgstr ""

#: ../../library/struct.rst:223
msgid "\\(6)"
msgstr ""

#: ../../library/struct.rst:226
msgid "Added support for the ``'n'`` and ``'N'`` formats."
msgstr ""

#: ../../library/struct.rst:232
msgid "The ``'?'`` conversion code corresponds to the :c:type:`_Bool` type defined by C99. If this type is not available, it is simulated using a :c:type:`char`. In standard mode, it is always represented by one byte."
msgstr ""

#: ../../library/struct.rst:237
msgid "The ``'q'`` and ``'Q'`` conversion codes are available in native mode only if the platform C compiler supports C :c:type:`long long`, or, on Windows, :c:type:`__int64`.  They are always available in standard modes."
msgstr ""

#: ../../library/struct.rst:242
msgid "When attempting to pack a non-integer using any of the integer conversion codes, if the non-integer has a :meth:`__index__` method then that method is called to convert the argument to an integer before packing."
msgstr ""

#: ../../library/struct.rst:246
msgid "Use of the :meth:`__index__` method for non-integers is new in 3.2."
msgstr ""

#: ../../library/struct.rst:250
msgid "The ``'n'`` and ``'N'`` conversion codes are only available for the native size (selected as the default or with the ``'@'`` byte order character). For the standard size, you can use whichever of the other integer formats fits your application."
msgstr ""

#: ../../library/struct.rst:256
msgid "For the ``'f'`` and ``'d'`` conversion codes, the packed representation uses the IEEE 754 binary32 (for ``'f'``) or binary64 (for ``'d'``) format, regardless of the floating-point format used by the platform."
msgstr ""

#: ../../library/struct.rst:261
msgid "The ``'P'`` format character is only available for the native byte ordering (selected as the default or with the ``'@'`` byte order character). The byte order character ``'='`` chooses to use little- or big-endian ordering based on the host system. The struct module does not interpret this as native ordering, so the ``'P'`` format is not available."
msgstr ""

#: ../../library/struct.rst:268
msgid "A format character may be preceded by an integral repeat count.  For example, the format string ``'4h'`` means exactly the same as ``'hhhh'``."
msgstr ""

#: ../../library/struct.rst:271
msgid "Whitespace characters between formats are ignored; a count and its format must not contain whitespace though."
msgstr ""

#: ../../library/struct.rst:274
msgid "For the ``'s'`` format character, the count is interpreted as the length of the bytes, not a repeat count like for the other format characters; for example, ``'10s'`` means a single 10-byte string, while ``'10c'`` means 10 characters. If a count is not given, it defaults to 1.  For packing, the string is truncated or padded with null bytes as appropriate to make it fit. For unpacking, the resulting bytes object always has exactly the specified number of bytes.  As a special case, ``'0s'`` means a single, empty string (while ``'0c'`` means 0 characters)."
msgstr ""

#: ../../library/struct.rst:283
msgid "When packing a value ``x`` using one of the integer formats (``'b'``, ``'B'``, ``'h'``, ``'H'``, ``'i'``, ``'I'``, ``'l'``, ``'L'``, ``'q'``, ``'Q'``), if ``x`` is outside the valid range for that format then :exc:`struct.error` is raised."
msgstr ""

#: ../../library/struct.rst:288
msgid "In 3.0, some of the integer formats wrapped out-of-range values and raised :exc:`DeprecationWarning` instead of :exc:`struct.error`."
msgstr ""

#: ../../library/struct.rst:292
msgid "The ``'p'`` format character encodes a \"Pascal string\", meaning a short variable-length string stored in a *fixed number of bytes*, given by the count. The first byte stored is the length of the string, or 255, whichever is smaller.  The bytes of the string follow.  If the string passed in to :func:`pack` is too long (longer than the count minus 1), only the leading ``count-1`` bytes of the string are stored.  If the string is shorter than ``count-1``, it is padded with null bytes so that exactly count bytes in all are used.  Note that for :func:`unpack`, the ``'p'`` format character consumes ``count`` bytes, but that the string returned can never contain more than 255 bytes."
msgstr ""

#: ../../library/struct.rst:303
msgid "For the ``'?'`` format character, the return value is either :const:`True` or :const:`False`. When packing, the truth value of the argument object is used. Either 0 or 1 in the native or standard bool representation will be packed, and any non-zero value will be ``True`` when unpacking."
msgstr ""

#: ../../library/struct.rst:313
msgid "Examples"
msgstr ""

#: ../../library/struct.rst:316
msgid "All examples assume a native byte order, size, and alignment with a big-endian machine."
msgstr ""

#: ../../library/struct.rst:319
msgid "A basic example of packing/unpacking three integers::"
msgstr ""

#: ../../library/struct.rst:329
msgid "Unpacked fields can be named by assigning them to variables or by wrapping the result in a named tuple::"
msgstr ""

#: ../../library/struct.rst:340
msgid "The ordering of format characters may have an impact on size since the padding needed to satisfy alignment requirements is different::"
msgstr ""

#: ../../library/struct.rst:352
msgid "The following format ``'llh0l'`` specifies two pad bytes at the end, assuming longs are aligned on 4-byte boundaries::"
msgstr ""

#: ../../library/struct.rst:358
msgid "This only works when native size and alignment are in effect; standard size and alignment does not enforce any alignment."
msgstr ""

#: ../../library/struct.rst:365
msgid "Module :mod:`array`"
msgstr ""

#: ../../library/struct.rst:365
msgid "Packed binary storage of homogeneous data."
msgstr ""

#: ../../library/struct.rst:367
msgid "Module :mod:`xdrlib`"
msgstr ""

#: ../../library/struct.rst:368
msgid "Packing and unpacking of XDR data."
msgstr ""

#: ../../library/struct.rst:374
msgid "Classes"
msgstr ""

#: ../../library/struct.rst:376
msgid "The :mod:`struct` module also defines the following type:"
msgstr ""

#: ../../library/struct.rst:381
msgid "Return a new Struct object which writes and reads binary data according to the format string *format*.  Creating a Struct object once and calling its methods is more efficient than calling the :mod:`struct` functions with the same format since the format string only needs to be compiled once."
msgstr ""

#: ../../library/struct.rst:387
msgid "Compiled Struct objects support the following methods and attributes:"
msgstr ""

#: ../../library/struct.rst:391
msgid "Identical to the :func:`pack` function, using the compiled format. (``len(result)`` will equal :attr:`self.size`.)"
msgstr ""

#: ../../library/struct.rst:397
msgid "Identical to the :func:`pack_into` function, using the compiled format."
msgstr ""

#: ../../library/struct.rst:402
msgid "Identical to the :func:`unpack` function, using the compiled format. (``len(buffer)`` must equal :attr:`self.size`)."
msgstr ""

#: ../../library/struct.rst:408
msgid "Identical to the :func:`unpack_from` function, using the compiled format. (``len(buffer[offset:])`` must be at least :attr:`self.size`)."
msgstr ""

#: ../../library/struct.rst:414
msgid "Identical to the :func:`iter_unpack` function, using the compiled format. (``len(buffer)`` must be a multiple of :attr:`self.size`)."
msgstr ""

#: ../../library/struct.rst:421
msgid "The format string used to construct this Struct object."
msgstr ""

#: ../../library/struct.rst:425
msgid "The calculated size of the struct (and hence of the bytes object produced by the :meth:`pack` method) corresponding to :attr:`format`."
msgstr ""

