# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-01-31 15:04+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../library/typing.rst:2
msgid ":mod:`typing` --- Support for type hints"
msgstr ""

#: ../../library/typing.rst:7
msgid "**Source code:** :source:`Lib/typing.py`"
msgstr ""

#: ../../library/typing.rst:11
msgid "This module supports type hints as specified by :pep:`484`.  The most fundamental support consists of the type :class:`Any`, :class:`Union`, :class:`Tuple`, :class:`Callable`, :class:`TypeVar`, and :class:`Generic`.  For full specification please see :pep:`484`.  For a simplified introduction to type hints see :pep:`483`."
msgstr ""

#: ../../library/typing.rst:18
msgid "The function below takes and returns a string and is annotated as follows::"
msgstr ""

#: ../../library/typing.rst:23
msgid "In the function ``greeting``, the argument ``name`` is expected to by of type :class:`str` and the return type :class:`str`. Subtypes are accepted as arguments."
msgstr ""

#: ../../library/typing.rst:28
msgid "Type aliases"
msgstr ""

#: ../../library/typing.rst:30
msgid "A type alias is defined by assigning the type to the alias::"
msgstr ""

#: ../../library/typing.rst:35
msgid "Callable"
msgstr ""

#: ../../library/typing.rst:37
msgid "Frameworks expecting callback functions of specific signatures might be type hinted using ``Callable[[Arg1Type, Arg2Type], ReturnType]``."
msgstr ""

#: ../../library/typing.rst:40
msgid "For example::"
msgstr ""

#: ../../library/typing.rst:51
msgid "It is possible to declare the return type of a callable without specifying the call signature by substituting a literal ellipsis for the list of arguments in the type hint: ``Callable[..., ReturnType]``. ``None`` as a type hint is a special case and is replaced by ``type(None)``."
msgstr ""

#: ../../library/typing.rst:57
msgid "Generics"
msgstr ""

#: ../../library/typing.rst:59
msgid "Since type information about objects kept in containers cannot be statically inferred in a generic way, abstract base classes have been extended to support subscription to denote expected types for container elements."
msgstr ""

#: ../../library/typing.rst:70
msgid "Generics can be parametrized by using a new factory available in typing called :class:`TypeVar`."
msgstr ""

#: ../../library/typing.rst:84
msgid "User-defined generic types"
msgstr ""

#: ../../library/typing.rst:86
msgid "A user-defined class can be defined as a generic class."
msgstr ""

#: ../../library/typing.rst:112
msgid "``Generic[T]`` as a base class defines that the class ``LoggedVar`` takes a single type parameter ``T`` . This also makes ``T`` valid as a type within the class body."
msgstr ""

#: ../../library/typing.rst:116
msgid "The :class:`Generic` base class uses a metaclass that defines :meth:`__getitem__` so that ``LoggedVar[t]`` is valid as a type::"
msgstr ""

#: ../../library/typing.rst:125
msgid "A generic type can have any number of type variables, and type variables may be constrained::"
msgstr ""

#: ../../library/typing.rst:137
msgid "Each type variable argument to :class:`Generic` must be distinct. This is thus invalid::"
msgstr ""

#: ../../library/typing.rst:148
msgid "You can use multiple inheritance with :class:`Generic`::"
msgstr ""

#: ../../library/typing.rst:157
msgid "When inheriting from generic classes, some type variables could fixed::"
msgstr ""

#: ../../library/typing.rst:166
msgid "In this case ``MyDict`` has a single parameter, ``T``."
msgstr ""

#: ../../library/typing.rst:168
msgid "Subclassing a generic class without specifying type parameters assumes :class:`Any` for each position. In the following example, ``MyIterable`` is not generic but implicitly inherits from ``Iterable[Any]``::"
msgstr ""

#: ../../library/typing.rst:176
msgid "The metaclass used by :class:`Generic` is a subclass of :class:`abc.ABCMeta`. A generic class can be an ABC by including abstract methods or properties, and generic classes can also have ABCs as base classes without a metaclass conflict.  Generic metaclasses are not supported."
msgstr ""

#: ../../library/typing.rst:183
msgid "The :class:`Any` type"
msgstr ""

#: ../../library/typing.rst:185
msgid "A special kind of type is :class:`Any`. Every type is a subtype of :class:`Any`. This is also true for the builtin type object. However, to the static type checker these are completely different."
msgstr ""

#: ../../library/typing.rst:189
msgid "When the type of a value is :class:`object`, the type checker will reject almost all operations on it, and assigning it to a variable (or using it as a return value) of a more specialized type is a type error. On the other hand, when a value has type :class:`Any`, the type checker will allow all operations on it, and a value of type :class:`Any` can be assigned to a variable (or used as a return value) of a more constrained type."
msgstr ""

#: ../../library/typing.rst:198
msgid "Classes, functions, and decorators"
msgstr ""

#: ../../library/typing.rst:200
msgid "The module defines the following classes, functions and decorators:"
msgstr ""

#: ../../library/typing.rst:204
msgid "Special type indicating an unconstrained type."
msgstr ""

#: ../../library/typing.rst:206
msgid "Any object is an instance of :class:`Any`."
msgstr ""

#: ../../library/typing.rst:207
msgid "Any class is a subclass of :class:`Any`."
msgstr ""

#: ../../library/typing.rst:208
msgid "As a special case, :class:`Any` and :class:`object` are subclasses of each other."
msgstr ""

#: ../../library/typing.rst:213
msgid "Type variable."
msgstr ""

#: ../../library/typing.rst:215
#: ../../library/typing.rst:479
msgid "Usage::"
msgstr ""

#: ../../library/typing.rst:220
msgid "Type variables exist primarily for the benefit of static type checkers.  They serve as the parameters for generic types as well as for generic function definitions.  See class Generic for more information on generic types.  Generic functions work as follows::"
msgstr ""

#: ../../library/typing.rst:233
msgid "The latter example's signature is essentially the overloading of ``(str, str) -> str`` and ``(bytes, bytes) -> bytes``.  Also note that if the arguments are instances of some subclass of :class:`str`, the return type is still plain :class:`str`."
msgstr ""

#: ../../library/typing.rst:238
msgid "At runtime, ``isinstance(x, T)`` will raise :exc:`TypeError`.  In general, :func:`isinstance` and :func:`issubclass` should not be used with types."
msgstr ""

#: ../../library/typing.rst:241
msgid "Type variables may be marked covariant or contravariant by passing ``covariant=True`` or ``contravariant=True``.  See :pep:`484` for more details.  By default type variables are invariant.  Alternatively, a type variable may specify an upper bound using ``bound=<type>``. This means that an actual type substituted (explicitly or implicitly) for the type variable must be a subclass of the boundary type, see :pep:`484`."
msgstr ""

#: ../../library/typing.rst:251
msgid "Union type; ``Union[X, Y]`` means either X or Y."
msgstr ""

#: ../../library/typing.rst:253
msgid "To define a union, use e.g. ``Union[int, str]``.  Details:"
msgstr ""

#: ../../library/typing.rst:255
msgid "The arguments must be types and there must be at least one."
msgstr ""

#: ../../library/typing.rst:257
msgid "Unions of unions are flattened, e.g.::"
msgstr ""

#: ../../library/typing.rst:261
msgid "Unions of a single argument vanish, e.g.::"
msgstr ""

#: ../../library/typing.rst:265
msgid "Redundant arguments are skipped, e.g.::"
msgstr ""

#: ../../library/typing.rst:269
msgid "When comparing unions, the argument order is ignored, e.g.::"
msgstr ""

#: ../../library/typing.rst:273
msgid "If :class:`Any` is present it is the sole survivor, e.g.::"
msgstr ""

#: ../../library/typing.rst:277
msgid "You cannot subclass or instantiate a union."
msgstr ""

#: ../../library/typing.rst:279
msgid "You cannot write ``Union[X][Y]``."
msgstr ""

#: ../../library/typing.rst:281
msgid "You can use ``Optional[X]`` as a shorthand for ``Union[X, None]``."
msgstr ""

#: ../../library/typing.rst:285
msgid "Optional type."
msgstr ""

#: ../../library/typing.rst:287
msgid "``Optional[X]`` is equivalent to ``Union[X, type(None)]``."
msgstr ""

#: ../../library/typing.rst:291
msgid "Tuple type; ``Tuple[X, Y]`` is the is the type of a tuple of two items with the first item of type X and the second of type Y."
msgstr ""

#: ../../library/typing.rst:294
msgid "Example: ``Tuple[T1, T2]`` is a tuple of two elements corresponding to type variables T1 and T2.  ``Tuple[int, float, str]`` is a tuple of an int, a float and a string."
msgstr ""

#: ../../library/typing.rst:298
msgid "To specify a variable-length tuple of homogeneous type, use literal ellipsis, e.g. ``Tuple[int, ...]``."
msgstr ""

#: ../../library/typing.rst:303
msgid "Callable type; ``Callable[[int], str]`` is a function of (int) -> str."
msgstr ""

#: ../../library/typing.rst:305
msgid "The subscription syntax must always be used with exactly two values: the argument list and the return type.  The argument list must be a list of types; the return type must be a single type."
msgstr ""

#: ../../library/typing.rst:309
msgid "There is no syntax to indicate optional or keyword arguments, such function types are rarely used as callback types. ``Callable[..., ReturnType]`` could be used to type hint a callable taking any number of arguments and returning ``ReturnType``. A plain :class:`Callable` is equivalent to ``Callable[..., Any]``."
msgstr ""

#: ../../library/typing.rst:317
msgid "Abstract base class for generic types."
msgstr ""

#: ../../library/typing.rst:319
msgid "A generic type is typically declared by inheriting from an instantiation of this class with one or more type variables. For example, a generic mapping type might be defined as::"
msgstr ""

#: ../../library/typing.rst:328
msgid "This class can then be used as follows::"
msgstr ""

#: ../../library/typing.rst:341
msgid "A generic version of the :class:`collections.abc.Iterable`."
msgstr ""

#: ../../library/typing.rst:345
msgid "A generic version of the :class:`collections.abc.Iterator`."
msgstr ""

#: ../../library/typing.rst:349
msgid "An ABC with one abstract method ``__int__``."
msgstr ""

#: ../../library/typing.rst:353
msgid "An ABC with one abstract method ``__float__``."
msgstr ""

#: ../../library/typing.rst:357
msgid "An ABC with one abstract method ``__abs__`` that is covariant in its return type."
msgstr ""

#: ../../library/typing.rst:362
msgid "An ABC with one abstract method ``__round__`` that is covariant in its return type."
msgstr ""

#: ../../library/typing.rst:367
msgid "An ABC with one abstract method ``__reversed__`` returning an ``Iterator[T_co]``."
msgstr ""

#: ../../library/typing.rst:372
msgid "A generic version of :class:`collections.abc.Container`."
msgstr ""

#: ../../library/typing.rst:376
#: ../../library/typing.rst:427
msgid "A generic version of :class:`collections.abc.Set`."
msgstr ""

#: ../../library/typing.rst:380
msgid "A generic version of :class:`collections.abc.MutableSet`."
msgstr ""

#: ../../library/typing.rst:384
msgid "A generic version of :class:`collections.abc.Mapping`."
msgstr ""

#: ../../library/typing.rst:388
msgid "A generic version of :class:`collections.abc.MutableMapping`."
msgstr ""

#: ../../library/typing.rst:392
msgid "A generic version of :class:`collections.abc.Sequence`."
msgstr ""

#: ../../library/typing.rst:396
msgid "A generic version of :class:`collections.abc.MutableSequence`."
msgstr ""

#: ../../library/typing.rst:400
msgid "A generic version of :class:`collections.abc.ByteString`."
msgstr ""

#: ../../library/typing.rst:402
msgid "This type represents the types :class:`bytes`, :class:`bytearray`, and :class:`memoryview`."
msgstr ""

#: ../../library/typing.rst:405
msgid "As a shorthand for this type, :class:`bytes` can be used to annotate arguments of any of the types mentioned above."
msgstr ""

#: ../../library/typing.rst:410
msgid "Generic version of :class:`list`. Useful for annotating return types. To annotate arguments it is preferred to use abstract collection types such as :class:`Mapping`, :class:`Sequence`, or :class:`AbstractSet`."
msgstr ""

#: ../../library/typing.rst:415
msgid "This type may be used as follows::"
msgstr ""

#: ../../library/typing.rst:431
msgid "A generic version of :class:`collections.abc.MappingView`."
msgstr ""

#: ../../library/typing.rst:435
msgid "A generic version of :class:`collections.abc.KeysView`."
msgstr ""

#: ../../library/typing.rst:439
msgid "A generic version of :class:`collections.abc.ItemsView`."
msgstr ""

#: ../../library/typing.rst:443
msgid "A generic version of :class:`collections.abc.ValuesView`."
msgstr ""

#: ../../library/typing.rst:447
msgid "A generic version of :class:`dict`. The usage of this type is as follows::"
msgstr ""

#: ../../library/typing.rst:457
msgid "Wrapper namespace for I/O stream types."
msgstr ""

#: ../../library/typing.rst:459
msgid "This defines the generic type ``IO[AnyStr]`` and aliases ``TextIO`` and ``BinaryIO`` for respectively ``IO[str]`` and ``IO[bytes]``. These representing the types of I/O streams such as returned by :func:`open`."
msgstr ""

#: ../../library/typing.rst:466
msgid "Wrapper namespace for regular expression matching types."
msgstr ""

#: ../../library/typing.rst:468
msgid "This defines the type aliases ``Pattern`` and ``Match`` which correspond to the return types from :func:`re.compile` and :func:`re.match`.  These types (and the corresponding functions) are generic in ``AnyStr`` and can be made specific by writing ``Pattern[str]``, ``Pattern[bytes]``, ``Match[str]``, or ``Match[bytes]``."
msgstr ""

#: ../../library/typing.rst:477
msgid "Typed version of namedtuple."
msgstr ""

#: ../../library/typing.rst:483
msgid "This is equivalent to::"
msgstr ""

#: ../../library/typing.rst:487
msgid "The resulting class has one extra attribute: _field_types, giving a dict mapping field names to types.  (The field names are in the _fields attribute, which is part of the namedtuple API.)"
msgstr ""

#: ../../library/typing.rst:494
msgid "Cast a value to a type."
msgstr ""

#: ../../library/typing.rst:496
msgid "This returns the value unchanged.  To the type checker this signals that the return value has the designated type, but at runtime we intentionally don't check anything (we want this to be as fast as possible)."
msgstr ""

#: ../../library/typing.rst:503
msgid "Return type hints for a function or method object."
msgstr ""

#: ../../library/typing.rst:505
msgid "This is often the same as ``obj.__annotations__``, but it handles forward references encoded as string literals, and if necessary adds ``Optional[t]`` if a default value equal to None is set."
msgstr ""

#: ../../library/typing.rst:511
msgid "Decorator to indicate that annotations are not type hints."
msgstr ""

#: ../../library/typing.rst:513
msgid "The argument must be a class or function; if it is a class, it applies recursively to all methods defined in that class (but not to methods defined in its superclasses or subclasses)."
msgstr ""

#: ../../library/typing.rst:517
msgid "This mutates the function(s) in place."
msgstr ""

#: ../../library/typing.rst:521
msgid "Decorator to give another decorator the :func:`no_type_check` effect."
msgstr ""

#: ../../library/typing.rst:523
msgid "This wraps the decorator with something that wraps the decorated function in :func:`no_type_check`."
msgstr ""

