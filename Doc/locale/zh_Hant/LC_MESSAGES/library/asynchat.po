# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2015, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.5 TW\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-12-09 21:33+0800\n"
"PO-Revision-Date: 2015-12-11 18:41+0000\n"
"Last-Translator: Liang Bo Wang <ccwang002@gmail.com>\n"
"Language-Team: Chinese Traditional (http://www.transifex.com/python-tw-doc/python-35-tw/language/zh-Hant/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh-Hant\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asynchat.rst:2
msgid ":mod:`asynchat` --- Asynchronous socket command/response handler"
msgstr ""

#: ../../library/asynchat.rst:9
msgid "**Source code:** :source:`Lib/asynchat.py`"
msgstr ""

#: ../../library/asynchat.rst:15
msgid ""
"This module exists for backwards compatibility only.  For new code we "
"recommend using :mod:`asyncio`."
msgstr ""

#: ../../library/asynchat.rst:18
msgid ""
"This module builds on the :mod:`asyncore` infrastructure, simplifying "
"asynchronous clients and servers and making it easier to handle protocols "
"whose elements are terminated by arbitrary strings, or are of variable "
"length. :mod:`asynchat` defines the abstract class :class:`async_chat` that "
"you subclass, providing implementations of the :meth:`collect_incoming_data`"
" and :meth:`found_terminator` methods. It uses the same asynchronous loop as"
" :mod:`asyncore`, and the two types of channel, :class:`asyncore.dispatcher`"
" and :class:`asynchat.async_chat`, can freely be mixed in the channel map. "
"Typically an :class:`asyncore.dispatcher` server channel generates new "
":class:`asynchat.async_chat` channel objects as it receives incoming "
"connection requests."
msgstr ""

#: ../../library/asynchat.rst:33
msgid ""
"This class is an abstract subclass of :class:`asyncore.dispatcher`. To make "
"practical use of the code you must subclass :class:`async_chat`, providing "
"meaningful :meth:`collect_incoming_data` and :meth:`found_terminator` "
"methods. The :class:`asyncore.dispatcher` methods can be used, although not "
"all make sense in a message/response context."
msgstr ""

#: ../../library/asynchat.rst:40
msgid ""
"Like :class:`asyncore.dispatcher`, :class:`async_chat` defines a set of "
"events that are generated by an analysis of socket conditions after a "
":c:func:`select` call. Once the polling loop has been started the "
":class:`async_chat` object's methods are called by the event-processing "
"framework with no action on the part of the programmer."
msgstr ""

#: ../../library/asynchat.rst:46
msgid ""
"Two class attributes can be modified, to improve performance, or possibly "
"even to conserve memory."
msgstr ""

#: ../../library/asynchat.rst:52
msgid "The asynchronous input buffer size (default ``4096``)."
msgstr ""

#: ../../library/asynchat.rst:57
msgid "The asynchronous output buffer size (default ``4096``)."
msgstr ""

#: ../../library/asynchat.rst:59
msgid ""
"Unlike :class:`asyncore.dispatcher`, :class:`async_chat` allows you to "
"define a first-in-first-out queue (fifo) of *producers*. A producer need "
"have only one method, :meth:`more`, which should return data to be "
"transmitted on the channel. The producer indicates exhaustion (*i.e.* that "
"it contains no more data) by having its :meth:`more` method return the empty"
" bytes object. At this point the :class:`async_chat` object removes the "
"producer from the fifo and starts using the next producer, if any. When the "
"producer fifo is empty the :meth:`handle_write` method does nothing. You use"
" the channel object's :meth:`set_terminator` method to describe how to "
"recognize the end of, or an important breakpoint in, an incoming "
"transmission from the remote endpoint."
msgstr ""

#: ../../library/asynchat.rst:72
msgid ""
"To build a functioning :class:`async_chat` subclass your  input methods "
":meth:`collect_incoming_data` and :meth:`found_terminator` must handle the "
"data that the channel receives asynchronously. The methods are described "
"below."
msgstr ""

#: ../../library/asynchat.rst:80
msgid ""
"Pushes a ``None`` on to the producer fifo. When this producer is popped off "
"the fifo it causes the channel to be closed."
msgstr ""

#: ../../library/asynchat.rst:86
msgid ""
"Called with *data* holding an arbitrary amount of received data.  The "
"default method, which must be overridden, raises a "
":exc:`NotImplementedError` exception."
msgstr ""

#: ../../library/asynchat.rst:93
msgid ""
"In emergencies this method will discard any data held in the input and/or "
"output buffers and the producer fifo."
msgstr ""

#: ../../library/asynchat.rst:99
msgid ""
"Called when the incoming data stream  matches the termination condition set "
"by :meth:`set_terminator`. The default method, which must be overridden, "
"raises a :exc:`NotImplementedError` exception. The buffered input data "
"should be available via an instance attribute."
msgstr ""

#: ../../library/asynchat.rst:107
msgid "Returns the current terminator for the channel."
msgstr ""

#: ../../library/asynchat.rst:112
msgid ""
"Pushes data on to the channel's fifo to ensure its transmission. This is all"
" you need to do to have the channel write the data out to the network, "
"although it is possible to use your own producers in more complex schemes to"
" implement encryption and chunking, for example."
msgstr ""

#: ../../library/asynchat.rst:120
msgid ""
"Takes a producer object and adds it to the producer fifo associated with the"
" channel.  When all currently-pushed producers have been exhausted the "
"channel will consume this producer's data by calling its :meth:`more` method"
" and send the data to the remote endpoint."
msgstr ""

#: ../../library/asynchat.rst:128
msgid ""
"Sets the terminating condition to be recognized on the channel.  ``term`` "
"may be any of three types of value, corresponding to three different ways to"
" handle incoming protocol data."
msgstr ""

#: ../../library/asynchat.rst:133
msgid "term"
msgstr ""

#: ../../library/asynchat.rst:133
msgid "Description"
msgstr "描述"

#: ../../library/asynchat.rst:135
msgid "*string*"
msgstr ""

#: ../../library/asynchat.rst:135
msgid ""
"Will call :meth:`found_terminator` when the string is found in the input "
"stream"
msgstr ""

#: ../../library/asynchat.rst:138
msgid "*integer*"
msgstr ""

#: ../../library/asynchat.rst:138
msgid ""
"Will call :meth:`found_terminator` when the indicated number of characters "
"have been received"
msgstr ""

#: ../../library/asynchat.rst:142
msgid "``None``"
msgstr ""

#: ../../library/asynchat.rst:142
msgid "The channel continues to collect data forever"
msgstr ""

#: ../../library/asynchat.rst:146
msgid ""
"Note that any data following the terminator will be available for reading by"
" the channel after :meth:`found_terminator` is called."
msgstr ""

#: ../../library/asynchat.rst:153
msgid "asynchat Example"
msgstr ""

#: ../../library/asynchat.rst:155
msgid ""
"The following partial example shows how HTTP requests can be read with "
":class:`async_chat`.  A web server might create an "
":class:`http_request_handler` object for each incoming client connection. "
"Notice that initially the channel terminator is set to match the blank line "
"at the end of the HTTP headers, and a flag indicates that the headers are "
"being read."
msgstr ""

#: ../../library/asynchat.rst:162
msgid ""
"Once the headers have been read, if the request is of type POST (indicating "
"that further data are present in the input stream) then the ``Content-"
"Length:`` header is used to set a numeric terminator to read the right "
"amount of data from the channel."
msgstr ""

#: ../../library/asynchat.rst:167
msgid ""
"The :meth:`handle_request` method is called once all relevant input has been"
" marshalled, after setting the channel terminator to ``None`` to ensure that"
" any extraneous data sent by the web client are ignored. ::"
msgstr ""
